// Code generated by jsonsumtype. DO NOT EDIT.

package shape

import (
	"errors"
	"github.com/go-json-experiment/json"
	"github.com/go-json-experiment/json/jsontext"
	"reflect"
	"strconv"
	"strings"
)

// Suppress "imported and not used" errors
var (
	_ = errors.New
	_ = json.Marshal
	_ = jsontext.Null
	_ = reflect.TypeOf
	_ = strconv.Quote
	_ = strings.Clone
)

var (
	// errMultipleObjectTags is returned if more than one tag is encountered
	// when decoding an object.
	errMultipleObjectTags = errors.New("multiple object tags")

	// errInvalidTuple is returned if an unexpected token is encountered
	// when decoding an array that must be a 2-tuple.
	errInvalidTuple = errors.New("invalid tuple")
)

// unknownTypeError is returned if unknown type is encountered when encoding a
// sum type.
type unknownTypeError struct {
	// Type is the type of the value that is being encoded.
	Type reflect.Type
}

// Error implements the error interface.
func (e *unknownTypeError) Error() string {
	return "unknown type " + e.Type.String()
}

// invalidTagError is returned if invalid tag is encountered when
// decoding an object.
type invalidTagError string

// Error implements the error interface.
func (e invalidTagError) Error() string {
	return "invalid tag " + strconv.Quote(string(e))
}

// invalidKindError is returned if invalid value kind is encountered when
// decoding a value.
type invalidKindError jsontext.Kind

// Error implements the error interface.
func (e invalidKindError) Error() string {
	return "invalid kind " + strconv.Quote(jsontext.Kind(e).String())
}

// unmarshalShapeExternallyTagged is a [json.UnmarshalFromFunc] decoder function that decodes
// Shape sum type from an externally tagged object.
//
// The following tags are supported:
//
//   - "circle" (Circle type)
//   - "square" (Square type)
func unmarshalShapeExternallyTagged(dec *jsontext.Decoder, out *Shape) error {
	switch k := dec.PeekKind(); k {
	case '{': // OK
	case 'n': // null
		*out = nil
		_, err := dec.ReadToken()
		return err
	default:
		return invalidKindError(k)
	}

	if _, err := dec.ReadToken(); err != nil {
		return err
	}

	if dec.PeekKind() == '}' {
		_, err := dec.ReadToken()
		return err
	}

	token, err := dec.ReadToken()
	if err != nil {
		return err
	}

	switch tag := token.String(); tag {
	case "circle":
		v, _ := (*out).(Circle)
		if err := json.UnmarshalDecode(dec, &v); err != nil {
			return err
		}
		*out = v
	case "square":
		v, _ := (*out).(Square)
		if err := json.UnmarshalDecode(dec, &v); err != nil {
			return err
		}
		*out = v
	default:
		return invalidTagError(strings.Clone(tag))
	}

	if dec.PeekKind() != '}' {
		return errMultipleObjectTags
	}

	_, err = dec.ReadToken()
	return err
}

// marshalShapeExternallyTagged is a [json.MarshalToFunc] encoder function that encodes
// Shape sum type as an externally tagged object.
//
// The following types are supported:
//
//   - Circle ("circle" tag)
//   - Square ("square" tag)
func marshalShapeExternallyTagged(enc *jsontext.Encoder, in *Shape) error {
	if *in == nil {
		return enc.WriteToken(jsontext.Null)
	}

	if err := enc.WriteToken(jsontext.BeginObject); err != nil {
		return err
	}

	switch v := (*in).(type) {
	case Circle:
		if err := enc.WriteToken(jsontext.String("circle")); err != nil {
			return err
		}

		if err := json.MarshalEncode(enc, v); err != nil {
			return err
		}
	case Square:
		if err := enc.WriteToken(jsontext.String("square")); err != nil {
			return err
		}

		if err := json.MarshalEncode(enc, v); err != nil {
			return err
		}
	default:
		return &unknownTypeError{
			Type: reflect.TypeOf(v),
		}
	}

	return enc.WriteToken(jsontext.EndObject)
}

// unmarshalShapeTaggedTuple is a [json.UnmarshalFromFunc] decoder function that decodes
// Shape sum type from a tagged tuple.
//
// The following tags are supported:
//
//   - "circle" (Circle type)
//   - "square" (Square type)
func unmarshalShapeTaggedTuple(dec *jsontext.Decoder, out *Shape) error {
	switch k := dec.PeekKind(); k {
	case '[': // OK
	case 'n': // null
		*out = nil
		_, err := dec.ReadToken()
		return err
	default:
		return invalidKindError(k)
	}

	if _, err := dec.ReadToken(); err != nil {
		return err
	}

	switch dec.PeekKind() {
	case '"': // OK
	case ']': // empty array
		if _, err := dec.ReadToken(); err != nil {
			return err
		}
	default:
		return errInvalidTuple
	}

	token, err := dec.ReadToken()
	if err != nil {
		return err
	}

	tag := token.String()

	if dec.PeekKind() == ']' {
		return errInvalidTuple
	}

	switch tag {
	case "circle":
		v, _ := (*out).(Circle)
		if err := json.UnmarshalDecode(dec, &v); err != nil {
			return err
		}
		*out = v
	case "square":
		v, _ := (*out).(Square)
		if err := json.UnmarshalDecode(dec, &v); err != nil {
			return err
		}
		*out = v
	default:
		return invalidTagError(strings.Clone(tag))
	}

	if dec.PeekKind() != ']' {
		return errInvalidTuple
	}

	_, err = dec.ReadToken()
	return err
}

// marshalShapeTaggedTuple is a [json.MarshalToFunc] encoder function that encodes
// Shape sum type as a tagged tuple.
//
// The following types are supported:
//
//   - Circle ("circle" tag)
//   - Square ("square" tag)
func marshalShapeTaggedTuple(enc *jsontext.Encoder, in *Shape) error {
	if *in == nil {
		return enc.WriteToken(jsontext.Null)
	}

	if err := enc.WriteToken(jsontext.BeginArray); err != nil {
		return err
	}

	switch v := (*in).(type) {
	case Circle:
		if err := enc.WriteToken(jsontext.String("circle")); err != nil {
			return err
		}

		if err := json.MarshalEncode(enc, v); err != nil {
			return err
		}
	case Square:
		if err := enc.WriteToken(jsontext.String("square")); err != nil {
			return err
		}

		if err := json.MarshalEncode(enc, v); err != nil {
			return err
		}
	default:
		return &unknownTypeError{
			Type: reflect.TypeOf(v),
		}
	}

	return enc.WriteToken(jsontext.EndArray)
}

// unmarshalShapeInternallyTagged is a [json.UnmarshalFromFunc] decoder function that decodes
// Shape sum type from an internally tagged object.
//
// The following tags are supported:
//
//   - "circle" (Circle type)
//   - "square" (Square type)
func unmarshalShapeInternallyTagged(dec *jsontext.Decoder, out *Shape) error {
	switch k := dec.PeekKind(); k {
	case '{': // OK
	case 'n': // null
		*out = nil
		_, err := dec.ReadToken()
		return err
	default:
		return invalidKindError(k)
	}

	var container struct {
		Tag     string         `json:"'tag'"`
		Content jsontext.Value `json:",inline"`
	}
	if err := json.UnmarshalDecode(dec, &container); err != nil {
		return err
	}

	in := []byte(container.Content)
	if len(in) == 0 {
		in = jsontext.Value("{}")
	}

	switch tag := container.Tag; tag {
	case "circle":
		v, _ := (*out).(Circle)
		if err := json.Unmarshal(in, &v, dec.Options()); err != nil {
			return err
		}
		*out = v
	case "square":
		v, _ := (*out).(Square)
		if err := json.Unmarshal(in, &v, dec.Options()); err != nil {
			return err
		}
		*out = v
	default:
		return invalidTagError(tag)
	}

	return nil
}

// marshalShapeInternallyTagged is a [json.MarshalToFunc] encoder function that encodes
// Shape sum type as an internally tagged object.
//
// The following types are supported:
//
//   - Circle ("circle" tag)
//   - Square ("square" tag)
func marshalShapeInternallyTagged(enc *jsontext.Encoder, in *Shape) error {
	if *in == nil {
		return enc.WriteToken(jsontext.Null)
	}

	// NB we encode twice to allow custom marshaler implementations,
	// including typed marshal functions specified in encoder options.
	// After encoding the value, we inline it into a container with tag.
	// JSON package will return an error if the encoding contains duplicate
	// tag field or is not an object.

	var container struct {
		Tag     string         `json:"'tag'"`
		Content jsontext.Value `json:",inline"`
	}

	switch v := (*in).(type) {
	case Circle:
		content, err := json.Marshal(v, enc.Options())
		if err != nil {
			return err
		}
		container.Tag = "circle"
		container.Content = jsontext.Value(content)
	case Square:
		content, err := json.Marshal(v, enc.Options())
		if err != nil {
			return err
		}
		container.Tag = "square"
		container.Content = jsontext.Value(content)
	default:
		return &unknownTypeError{
			Type: reflect.TypeOf(v),
		}
	}

	return json.MarshalEncode(enc, &container)
}

// unmarshalShapeAdjacentlyTagged is a [json.UnmarshalFromFunc] decoder function that decodes
// Shape sum type from an adjacently tagged object.
//
// The following tags are supported:
//
//   - "circle" (Circle type)
//   - "square" (Square type)
func unmarshalShapeAdjacentlyTagged(dec *jsontext.Decoder, out *Shape) error {
	switch k := dec.PeekKind(); k {
	case '{': // OK
	case 'n': // null
		*out = nil
		_, err := dec.ReadToken()
		return err
	default:
		return invalidKindError(k)
	}

	var container struct {
		Tag     string         `json:"'tag'"`
		Content jsontext.Value `json:"'content'"`
	}
	if err := json.UnmarshalDecode(dec, &container); err != nil {
		return err
	}

	in := []byte(container.Content)
	if len(in) == 0 {
		in = jsontext.Value("null")
	}

	switch tag := container.Tag; tag {
	case "circle":
		v, _ := (*out).(Circle)
		if err := json.Unmarshal(in, &v, dec.Options()); err != nil {
			return err
		}
		*out = v
	case "square":
		v, _ := (*out).(Square)
		if err := json.Unmarshal(in, &v, dec.Options()); err != nil {
			return err
		}
		*out = v
	default:
		return invalidTagError(tag)
	}

	return nil
}

// marshalShapeAdjacentlyTagged is a [json.MarshalToFunc] encoder function that encodes
// Shape sum type as an adjacently tagged object.
//
// The following types are supported:
//
//   - Circle ("circle" tag)
//   - Square ("square" tag)
func marshalShapeAdjacentlyTagged(enc *jsontext.Encoder, in *Shape) error {
	if *in == nil {
		return enc.WriteToken(jsontext.Null)
	}

	if err := enc.WriteToken(jsontext.BeginObject); err != nil {
		return err
	}

	switch v := (*in).(type) {
	case Circle:
		if err := enc.WriteToken(jsontext.String("tag")); err != nil {
			return err
		}
		if err := enc.WriteToken(jsontext.String("circle")); err != nil {
			return err
		}
		if err := enc.WriteToken(jsontext.String("content")); err != nil {
			return err
		}
		if err := json.MarshalEncode(enc, v); err != nil {
			return err
		}
	case Square:
		if err := enc.WriteToken(jsontext.String("tag")); err != nil {
			return err
		}
		if err := enc.WriteToken(jsontext.String("square")); err != nil {
			return err
		}
		if err := enc.WriteToken(jsontext.String("content")); err != nil {
			return err
		}
		if err := json.MarshalEncode(enc, v); err != nil {
			return err
		}
	default:
		return &unknownTypeError{
			Type: reflect.TypeOf(v),
		}
	}

	return enc.WriteToken(jsontext.EndObject)
}

// unmarshalShapeUntagged is a [json.UnmarshalFromFunc] decoder function that decodes
// Shape sum type from an untagged value.
//
// The following types are supported:
//
//   - Circle
//   - Square
func unmarshalShapeUntagged(dec *jsontext.Decoder, out *Shape) error {
	value, err := dec.ReadValue()
	if err != nil {
		return err
	}

	in := []byte(value)
	{
		v, _ := (*out).(Circle)
		err = json.Unmarshal(in, &v, dec.Options())
		if err == nil {
			*out = v
			goto exit
		}
	}
	{
		v, _ := (*out).(Square)
		err = json.Unmarshal(in, &v, dec.Options())
		if err == nil {
			*out = v
			goto exit
		}
	}
exit:
	return err
}

// marshalShapeUntagged is a [json.MarshalToFunc] encoder function that encodes
// Shape sum type as an untagged value.
//
// The following types are supported:
//
//   - Circle
//   - Square
func marshalShapeUntagged(enc *jsontext.Encoder, in *Shape) error {
	if *in == nil {
		return enc.WriteToken(jsontext.Null)
	}

	switch v := (*in).(type) {
	case Circle:
		return json.MarshalEncode(enc, v)
	case Square:
		return json.MarshalEncode(enc, v)
	default:
		return &unknownTypeError{
			Type: reflect.TypeOf(v),
		}
	}
}
