<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.Func</title>
<link href="../../css/auto-v0.7.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.7.6.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;">type <b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/object.go.html#line-389">Func</a></b></span>

<span class="title">106 uses</span>

	go/types (current package)
		<a href="../../src/go/types/builtins.go.html#line-730">builtins.go#L730</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/call.go.html#line-753">call.go#L753</a>: 			case *<b>Func</b>:
		<a href="../../src/go/types/call.go.html#line-842" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-842">#L842</a>: 	if m, _ := obj.(*<b>Func</b>); m != nil {
		<a href="../../src/go/types/call.go.html#line-848" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-848">#L848</a>: 		m, _ := obj.(*<b>Func</b>)
		<a href="../../src/go/types/call.go.html#line-905" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-905">#L905</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/check.go.html#line-190">check.go#L190</a>: 	methods  map[*TypeName][]*<b>Func</b> // maps package scope type names to associated non-blank (non-interface) methods
		<a href="../../src/go/types/decl.go.html#line-147">decl.go#L147</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-192" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-192">#L192</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-257" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-257">#L257</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-820" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-820">#L820</a>: 					_ = alt.(*<b>Func</b>)
		<a href="../../src/go/types/decl.go.html#line-834" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-834">#L834</a>: func (check *Checker) funcDecl(obj *<b>Func</b>, decl *declInfo) {
		<a href="../../src/go/types/errsupport.go.html#line-89">errsupport.go#L89</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/initorder.go.html#line-256">initorder.go#L256</a>: 		if _, ok := n.obj.(*<b>Func</b>); ok {
		<a href="../../src/go/types/interface.go.html#line-19">interface.go#L19</a>: 	methods   []*<b>Func</b>      // ordered list of explicitly declared methods
		<a href="../../src/go/types/interface.go.html#line-39" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-39">#L39</a>: func NewInterface(methods []*<b>Func</b>, embeddeds []*Named) *Interface {
		<a href="../../src/go/types/interface.go.html#line-53" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-53">#L53</a>: func NewInterfaceType(methods []*<b>Func</b>, embeddeds []Type) *Interface {
		<a href="../../src/go/types/interface.go.html#line-98" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-98">#L98</a>: func (t *Interface) ExplicitMethod(i int) *<b>Func</b> { return t.methods[i] }
		<a href="../../src/go/types/interface.go.html#line-117" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-117">#L117</a>: func (t *Interface) Method(i int) *<b>Func</b> { return t.typeSet().Method(i) }
		<a href="../../src/go/types/iter.go.html#line-20">iter.go#L20</a>: func (t *Interface) Methods() iter.Seq[*<b>Func</b>] {
		<a href="../../src/go/types/iter.go.html#line-21" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-21">#L21</a>: 	return func(yield func(m *<b>Func</b>) bool) {
		<a href="../../src/go/types/iter.go.html#line-34" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-34">#L34</a>: func (t *Interface) ExplicitMethods() iter.Seq[*<b>Func</b>] {
		<a href="../../src/go/types/iter.go.html#line-35" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-35">#L35</a>: 	return func(yield func(m *<b>Func</b>) bool) {
		<a href="../../src/go/types/iter.go.html#line-60" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-60">#L60</a>: func (t *Named) Methods() iter.Seq[*<b>Func</b>] {
		<a href="../../src/go/types/iter.go.html#line-61" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-61">#L61</a>: 	return func(yield func(m *<b>Func</b>) bool) {
		<a href="../../src/go/types/lookup.go.html#line-64">lookup.go#L64</a>: 			if _, ok := obj.(*<b>Func</b>); ok {
		<a href="../../src/go/types/lookup.go.html#line-219" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-219">#L219</a>: 			if f, _ := obj.(*<b>Func</b>); f != nil {
		<a href="../../src/go/types/lookup.go.html#line-324" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-324">#L324</a>: func MissingMethod(V Type, T *Interface, static bool) (method *<b>Func</b>, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-337" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-337">#L337</a>: func (check *Checker) missingMethod(V, T Type, static bool, equivalent func(x, y Type) bool, cause *string) (method *<b>Func</b>, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-355" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-355">#L355</a>: 	var m *<b>Func</b> // method on T we're trying to implement
		<a href="../../src/go/types/lookup.go.html#line-356" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-356">#L356</a>: 	var f *<b>Func</b> // method on V, if found (state is one of ok, wrongName, wrongSig)
		<a href="../../src/go/types/lookup.go.html#line-390" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-390">#L390</a>: 					f, _ = obj.(*<b>Func</b>)
		<a href="../../src/go/types/lookup.go.html#line-404" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-404">#L404</a>: 			f, _ = obj.(*<b>Func</b>)
		<a href="../../src/go/types/lookup.go.html#line-529" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-529">#L529</a>: func (check *Checker) funcString(f *<b>Func</b>, pkgInfo bool) string {
		<a href="../../src/go/types/lookup.go.html#line-625" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-625">#L625</a>: func methodIndex(methods []*<b>Func</b>, pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/methodset.go.html#line-218">methodset.go#L218</a>: func (s methodSet) add(list []*<b>Func</b>, index []int, indirect bool, multiples bool) methodSet {
		<a href="../../src/go/types/methodset.go.html#line-228" class="path-duplicate">methodset.go</a><a href="../../src/go/types/methodset.go.html#line-228">#L228</a>: func (s methodSet) addOne(f *<b>Func</b>, index []int, indirect bool, multiples bool) methodSet {
		<a href="../../src/go/types/named.go.html#line-131">named.go#L131</a>: 	methods []*<b>Func</b>
		<a href="../../src/go/types/named.go.html#line-134" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-134">#L134</a>: 	loader func(*Named) (tparams []*TypeParam, underlying Type, methods []*<b>Func</b>)
		<a href="../../src/go/types/named.go.html#line-158" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-158">#L158</a>: func NewNamed(obj *TypeName, underlying Type, methods []*<b>Func</b>) *Named {
		<a href="../../src/go/types/named.go.html#line-243" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-243">#L243</a>: func (check *Checker) newNamed(obj *TypeName, underlying Type, methods []*<b>Func</b>) *Named {
		<a href="../../src/go/types/named.go.html#line-358" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-358">#L358</a>: func (t *Named) Method(i int) *<b>Func</b> {
		<a href="../../src/go/types/named.go.html#line-373" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-373">#L373</a>: 		t.methods = make([]*<b>Func</b>, len(orig.methods))
		<a href="../../src/go/types/named.go.html#line-394" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-394">#L394</a>: func (t *Named) expandMethod(i int) *<b>Func</b> {
		<a href="../../src/go/types/named.go.html#line-470" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-470">#L470</a>: func (t *Named) AddMethod(m *<b>Func</b>) {
		<a href="../../src/go/types/named.go.html#line-608" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-608">#L608</a>: func (n *Named) lookupMethod(pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/object.go.html#line-299">object.go#L299</a>: func _NewTypeNameLazy(pos token.Pos, pkg *Package, name string, load func(named *Named) (tparams []*TypeParam, underlying Type, methods []*<b>Func</b>)) *TypeName {
		<a href="../../src/go/types/object.go.html#line-389" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-389">#L389</a>: type <b>Func</b> struct {
		<a href="../../src/go/types/object.go.html#line-392" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-392">#L392</a>: 	origin      *<b>Func</b> // if non-nil, the Func from which this one was instantiated
		<a href="../../src/go/types/object.go.html#line-397" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-397">#L397</a>: func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *<b>Func</b> {
		<a href="../../src/go/types/object.go.html#line-407" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-407">#L407</a>: 	return &amp;<b>Func</b>{object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}, false, nil}
		<a href="../../src/go/types/object.go.html#line-411" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-411">#L411</a>: func (obj *<b>Func</b>) Signature() *Signature {
		<a href="../../src/go/types/object.go.html#line-428" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-428">#L428</a>: func (obj *<b>Func</b>) FullName() string {
		<a href="../../src/go/types/object.go.html#line-437" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-437">#L437</a>: func (obj *<b>Func</b>) Scope() *Scope { return obj.typ.(*Signature).scope }
		<a href="../../src/go/types/object.go.html#line-446" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-446">#L446</a>: func (obj *<b>Func</b>) Origin() *<b>Func</b> {
		<a href="../../src/go/types/object.go.html#line-457" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-457">#L457</a>: func (obj *<b>Func</b>) Pkg() *Package { return obj.object.Pkg() }
		<a href="../../src/go/types/object.go.html#line-460" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-460">#L460</a>: func (obj *<b>Func</b>) hasPtrRecv() bool {
		<a href="../../src/go/types/object.go.html#line-478" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-478">#L478</a>: func (*<b>Func</b>) isDependency() {} // a function may be a dependency of an initialization expression
		<a href="../../src/go/types/object.go.html#line-537" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-537">#L537</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/object.go.html#line-639" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-639">#L639</a>: func (obj *<b>Func</b>) String() string     { return ObjectString(obj, nil) }
		<a href="../../src/go/types/object.go.html#line-644" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-644">#L644</a>: func writeFuncName(buf *bytes.Buffer, f *<b>Func</b>, qf Qualifier) {
		<a href="../../src/go/types/resolver.go.html#line-231">resolver.go#L231</a>: 		obj  *<b>Func</b>      // method
		<a href="../../src/go/types/resolver.go.html#line-492" class="path-duplicate">resolver.go</a><a href="../../src/go/types/resolver.go.html#line-492">#L492</a>: 	check.methods = make(map[*TypeName][]*<b>Func</b>)
		<a href="../../src/go/types/selection.go.html#line-100">selection.go#L100</a>: 		sig := *s.obj.(*<b>Func</b>).typ.(*Signature)
		<a href="../../src/go/types/selection.go.html#line-111" class="path-duplicate">selection.go</a><a href="../../src/go/types/selection.go.html#line-111">#L111</a>: 		sig := *s.obj.(*<b>Func</b>).typ.(*Signature)
		<a href="../../src/go/types/subst.go.html#line-332">subst.go#L332</a>: func (subst *subster) func_(f *<b>Func</b>) *<b>Func</b> {
		<a href="../../src/go/types/subst.go.html#line-341" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-341">#L341</a>: func cloneFunc(f *<b>Func</b>, typ Type) *<b>Func</b> {
		<a href="../../src/go/types/subst.go.html#line-361" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-361">#L361</a>: func replaceRecvType(in []*<b>Func</b>, old, new Type) (out []*<b>Func</b>, copied bool) {
		<a href="../../src/go/types/subst.go.html#line-370" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-370">#L370</a>: 				out = make([]*<b>Func</b>, len(in))
		<a href="../../src/go/types/typeset.go.html#line-30">typeset.go#L30</a>: 	methods    []*<b>Func</b>  // all methods of the interface; sorted by unique ID
		<a href="../../src/go/types/typeset.go.html#line-59" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-59">#L59</a>: func (s *_TypeSet) Method(i int) *<b>Func</b> { return s.methods[i] }
		<a href="../../src/go/types/typeset.go.html#line-62" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-62">#L62</a>: func (s *_TypeSet) LookupMethod(pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/typeset.go.html#line-221" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-221">#L221</a>: 	var allMethods []*<b>Func</b>
		<a href="../../src/go/types/typeset.go.html#line-222" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-222">#L222</a>: 	mpos := make(map[*<b>Func</b>]token.Pos) // method specification or method embedding position, for good error messages
		<a href="../../src/go/types/typeset.go.html#line-223" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-223">#L223</a>: 	addMethod := func(pos token.Pos, m *<b>Func</b>, explicit bool) {
		<a href="../../src/go/types/typeset.go.html#line-232" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-232">#L232</a>: 				err.addf(atPos(mpos[other.(*<b>Func</b>)]), "other declaration of method %s", m.name)
		<a href="../../src/go/types/typeset.go.html#line-246" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-246">#L246</a>: 						err.addf(atPos(mpos[other.(*<b>Func</b>)]), "other declaration of method %s", m.name)
		<a href="../../src/go/types/typeset.go.html#line-351" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-351">#L351</a>: func compareFunc(a, b *<b>Func</b>) int {
		<a href="../../src/go/types/typeset.go.html#line-355" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-355">#L355</a>: func sortMethods(list []*<b>Func</b>) {
		<a href="../../src/go/types/typeset.go.html#line-359" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-359">#L359</a>: func assertSortedMethods(list []*<b>Func</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-130">typexpr.go#L130</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/unify.go.html#line-516">unify.go#L516</a>: 			ymap := make(map[string]*<b>Func</b>, len(ymethods))
		<a href="../../src/go/types/unify.go.html#line-543" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-543">#L543</a>: 				if ym, _ := obj.(*<b>Func</b>); ym == nil || !u.nify(xm.typ, ym.typ, exact, p) {
		<a href="../../src/go/types/universe.go.html#line-131">universe.go#L131</a>: 		ityp := &amp;Interface{methods: []*<b>Func</b>{err}, complete: true}

	<a href="../../pkg/golang.org/x/exp/apidiff.html">golang.org/x/exp/apidiff</a>
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-132">apidiff.go#L132</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-134" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-134">#L134</a>: 		case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-178" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-178">#L178</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-127">compatibility.go#L127</a>: func unexportedMethod(t *types.Interface) *types.<b>Func</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-259">correspondence.go#L259</a>: func (d *differ) sortedMethods(iface *types.Interface) []*types.<b>Func</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-260" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-260">#L260</a>: 	ms := make([]*types.<b>Func</b>, iface.NumMethods())
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-268" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-268">#L268</a>: func (d *differ) methodID(m *types.<b>Func</b>) string {
		<a href="../../src/golang.org/x/exp/apidiff/messageset.go.html#line-58">messageset.go#L58</a>: 	if f, ok := obj.(*types.<b>Func</b>); ok {

	<a href="../../pkg/golang.org/x/tools/go/types/objectpath.html">golang.org/x/tools/go/types/objectpath</a>
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-248">objectpath.go#L248</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-351" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-351">#L351</a>: func (enc *Encoder) concreteMethod(meth *types.<b>Func</b>) (Path, bool) {

	<a href="../../pkg/golang.org/x/tools/internal/gcimporter.html">golang.org/x/tools/internal/gcimporter</a>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-471">iexport.go#L471</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-938">iimport.go#L938</a>: 		methods := make([]*types.<b>Func</b>, r.uint64())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-940" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-940">#L940</a>: 			var method *types.<b>Func</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-942" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-942">#L942</a>: 				method, _ = r.objectPathObject().(*types.<b>Func</b>)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/newInterface11.go^10e54.html#line-12">newInterface11.go#L12</a>: func newInterface(methods []*types.<b>Func</b>, embeddeds []types.Type) *types.Interface {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-406">ureader_yes.go#L406</a>: 	methods := make([]*types.<b>Func</b>, r.Len())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-557" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-557">#L557</a>: 					methods := make([]*types.<b>Func</b>, iface.NumExplicitMethods())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-698" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-698">#L698</a>: func (r *reader) method() *types.<b>Func</b> {
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.7.6</i>. (GOOS=linux GOARCH=amd64)</pre>